<!DOCTYPE html>
<html>
<head>
<style>
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    background: #000;
    width: 100%;
  }
  body {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100vh;
    width: 100vw;
    background: #000;
  }
  #video {
    width: 100vw;
    height: 100vh;
    object-fit: contain;
    background: #000;
    display: block;
  }
  #status {
    position: absolute;
    top: 10px;
    left: 0;
    width: 100vw;
    text-align: center;
    color: #fff;
    font-family: sans-serif;
    font-size: 1.2em;
    z-index: 10;
    pointer-events: none;
  }
</style>
</head>
<body>
<div style="position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000;overflow:hidden;">
  <video id="video" autoplay playsinline style="display:none;"></video>
  <canvas id="canvas" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:#000;max-width:100vw;max-height:100vh;display:none;"></canvas>
  <div id="status">Connecting...</div>
</div>
<script>
async function start() {
  const pc = new RTCPeerConnection({
    iceServers: [
      { urls: "stun:stun.l.google.com:19302" }
    ]
  });

  let serverTimestamp = null;
  pc.ondatachannel = (event) => {
    if (event.channel.label === "meta") {
      event.channel.onmessage = (msg) => {
        serverTimestamp = msg.data;
      };
    }
  };

  // Add a video transceiver to trigger ICE gathering and SDP media section
  pc.addTransceiver("video", { direction: "recvonly" });

  // Log all ICE candidates
  pc.onicecandidate = (event) => {
    console.log("ICE candidate:", event.candidate);
  };

  pc.ontrack = (event) => {
    console.log("Received remote track", event);
    const video = document.getElementById("video");
    if (event.streams && event.streams[0]) {
      video.srcObject = event.streams[0];
      video.onloadedmetadata = () => {
        video.play();
        startCanvasOverlay();
      };
    } else {
      console.warn("No streams in ontrack event", event);
    }
    document.getElementById("status").textContent = "Connected!";
  };

  function startCanvasOverlay() {
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      if (video.videoWidth && video.videoHeight) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        const vidAR = video.videoWidth / video.videoHeight;
        const winAR = winW / winH;
        let dispW, dispH;
        if (winAR > vidAR) {
          dispH = winH;
          dispW = winH * vidAR;
        } else {
          dispW = winW;
          dispH = winW / vidAR;
        }
        canvas.style.width = dispW + "px";
        canvas.style.height = dispH + "px";
        canvas.style.display = "block";
      }
    }
    // Initial resize in case metadata is already loaded
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
    video.addEventListener("loadedmetadata", () => {
      resizeCanvas();
      window.dispatchEvent(new Event("resize"));
    });

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      // Draw client time when new content is received
      const now = new Date();
      let ts = now.toLocaleString();
      let fontSize = Math.max(Math.floor(canvas.height/18), 24);
      ctx.font = fontSize + "px DejaVu Sans, Arial, sans-serif";
      ctx.fillStyle = "white";
      ctx.textBaseline = "bottom";
      ctx.shadowColor = "black";
      ctx.shadowBlur = 6;
      ctx.fillText(ts, 20, canvas.height - 20);
      ctx.shadowBlur = 0;
      requestAnimationFrame(draw);
    }
    draw();
  }

  // Monitor connection state
  pc.onconnectionstatechange = () => {
    console.log("Connection state:", pc.connectionState);
    document.getElementById("status").textContent = `Connection: ${pc.connectionState}`;
  };

  pc.oniceconnectionstatechange = () => {
    console.log("ICE connection state:", pc.iceConnectionState);
  };

  // Log SDP offer
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  // Wait for ICE gathering to complete before sending offer (with timeout)
  await Promise.race([
    new Promise(resolve => {
      if (pc.iceGatheringState === "complete") {
        resolve();
      } else {
        pc.addEventListener("icegatheringstatechange", function onStateChange() {
          if (pc.iceGatheringState === "complete") {
            pc.removeEventListener("icegatheringstatechange", onStateChange);
            resolve();
          }
        });
      }
    }),
    new Promise(resolve => setTimeout(resolve, 2000)) // 2 second timeout
  ]);

  // IMPORTANT: Use pc.localDescription here, after ICE gathering
  console.log("Offer SDP (ICE complete):\n", pc.localDescription.sdp);

  // Send offer to server
  console.log("Sending offer to server");
  const res = await fetch("/offer", {
    method: "POST",
    body: JSON.stringify(pc.localDescription), // use latest localDescription here
    headers: { "Content-Type": "application/json" },
  });

  if (!res.ok) {
    throw new Error(`HTTP ${res.status}: ${res.statusText}`);
  }

  const answer = await res.json();
  console.log("Received answer from server:", answer);
  console.log("Answer SDP:\n", answer.sdp);
  await pc.setRemoteDescription(answer);
  console.log("Set remote description");
}

start().catch(err => {
  console.error("Error:", err);
  document.getElementById("status").textContent = `Error: ${err.message}`;
});
</script>
</body>
</html>